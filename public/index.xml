<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog • Ken M. Haggerty</title>
    <link>http://kenmhaggerty.com/blog/</link>
    <description>Recent content on Blog • Ken M. Haggerty</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Jul 2016 15:21:19 -0400</lastBuildDate>
    <atom:link href="http://kenmhaggerty.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>KMHFirebaseController: A Cleaner API For Firebase</title>
      <link>http://kenmhaggerty.com/blog/post/firebase-controller/</link>
      <pubDate>Mon, 18 Jul 2016 15:21:19 -0400</pubDate>
      
      <guid>http://kenmhaggerty.com/blog/post/firebase-controller/</guid>
      <description>

&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;http://kenmhaggerty.com/blog/blog/images/firebase-controller/firebase_apple.png&#34;&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/&#34;&gt;&lt;strong&gt;Firebase&lt;/strong&gt;&lt;/a&gt; is an easy-to-use cross-platform &lt;a href=&#34;https://en.wikipedia.org/wiki/NoSQL&#34;&gt;NoSQL&lt;/a&gt; database, but even &amp;ldquo;easy-to-use&amp;rdquo; solutions can be &amp;ldquo;tiresome-to-learn&amp;rdquo; and messy when you&amp;rsquo;re used to other tools. While Firebase&amp;rsquo;s existing API is pretty robust, there are definitely some quirks to how it operates. As such, I&amp;rsquo;ve created my own custom interface to make integrating Firebase into your iOS app &lt;em&gt;even easier!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This custom class&amp;mdash;called, simply enough, &lt;a href=&#34;https://github.com/kenmhaggerty/KMHFirebaseController&#34;&gt;&lt;strong&gt;KMHFirebaseController&lt;/strong&gt;&lt;/a&gt;&amp;mdash;is &lt;a href=&#34;https://github.com/kenmhaggerty/KMHFirebaseController&#34;&gt;available on GitHub&lt;/a&gt;. In the past I&amp;rsquo;ve generally kept tools like these to myself (mostly out of lack-of-confidence), but in open sourcing this code I hope I can receive constructive criticism and recommendations for improvement. So fork away and submit your pull requests! :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KMHFirebaseController&lt;/strong&gt; contains class methods for setting up your Firebase project; pushing values to Firebase; querying Firebase; and observing Firebase. This library also includes a helper class called  &lt;strong&gt;KMHFirebaseQuery&lt;/strong&gt; for use in creating Firebase queries.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/kenmhaggerty/KMHFirebaseController/blob/master/KMHFirebaseController.h&#34;&gt;KMHFirebaseController.h&lt;/a&gt; file contains the full API, divided into the four general sections listed above and outlined below. Since my API is built on top of the existing Firebase iOS SDK, here is a link to the actual &lt;a href=&#34;https://firebase.google.com/docs/reference/ios/&#34;&gt;Firebase iOS SDK documentation&lt;/a&gt;, which I would still recommend familiarizing yourself with.&lt;/p&gt;

&lt;p&gt;This current version of KMHFirebaseController is compatible with Firebase 3.0 and later and written in Objective-C, but I&amp;rsquo;m hoping to push a backwards-compatible version soon in addition to an implementation in Swift.&lt;/p&gt;

&lt;p&gt;And don&amp;rsquo;t forget to add Firebase to your project by following the &lt;a href=&#34;https://firebase.google.com/docs/ios/setup&#34;&gt;&lt;strong&gt;Get Started Guide&lt;/strong&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;h1 id=&#34;kmhfirebasecontroller&#34;&gt;KMHFirebaseController&lt;/h1&gt;

&lt;h2 id=&#34;general-methods&#34;&gt;General Methods&lt;/h2&gt;

&lt;h4 id=&#34;void-setup&#34;&gt;+ (void)setup&lt;/h4&gt;

&lt;p&gt;Performs necessary application setup for Firebase and KMHFirebaseController; should be called from within &lt;code&gt;-[UIApplicationDelegate application:didFinishLaunchingWithOptions:]&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;bool-isconnected&#34;&gt;+ (BOOL)isConnected&lt;/h4&gt;

&lt;p&gt;Returns whether there is currently an active connection to Firebase.&lt;/p&gt;

&lt;h4 id=&#34;void-connect&#34;&gt;+ (void)connect&lt;/h4&gt;

&lt;p&gt;Enables a connection to Firebase if it has been previously disabled.&lt;/p&gt;

&lt;h4 id=&#34;void-disconnect&#34;&gt;+ (void)disconnect&lt;/h4&gt;

&lt;p&gt;Disables a connection to Firebase if it is currently active.&lt;/p&gt;

&lt;h2 id=&#34;data-methods&#34;&gt;Data Methods&lt;/h2&gt;

&lt;h4 id=&#34;void-setpriority-id-priority-forpath-nsstring-path-withcompletion-void-bool-success-nserror-error-completionblock&#34;&gt;+ (void)setPriority:(id)priority forPath:(NSString *)path withCompletion:(void(^)(BOOL success, NSError *error))completionBlock&lt;/h4&gt;

&lt;p&gt;As per &lt;a href=&#34;https://firebase.google.com/docs/reference/ios/firebasedatabase/interface_f_i_r_database_reference#a137281e08179107ae2d575328facf825&#34;&gt;Firebase&amp;rsquo;s documentation&lt;/a&gt;, priorities can be set per path to determine the order in which updates occur should sibling paths update simultaneously. Paths with no priority are processed first, followed by paths with numeric priorities and finally paths with string priorities.&lt;/p&gt;

&lt;h4 id=&#34;void-saveobject-id-object-topath-nsstring-path-withcompletion-void-bool-success-nserror-error-completionblock&#34;&gt;+ (void)saveObject:(id)object toPath:(NSString *)path withCompletion:(void (^)(BOOL success, NSError *error))completionBlock&lt;/h4&gt;

&lt;p&gt;Overwrites the object at the specified path with the given object and performs the given block upon completion. Valid object types include strings (NSString) and numbers and booleans (NSNumber). Setting the object for path to nil will remove that path from Firebase.&lt;/p&gt;

&lt;h4 id=&#34;void-updateobjectatpath-nsstring-path-withdictionary-nsdictionary-dictionary-andcompletion-void-bool-success-nserror-error-completionblock&#34;&gt;+ (void)updateObjectAtPath:(NSString *)path withDictionary:(NSDictionary *)dictionary andCompletion:(void (^)(BOOL success, NSError *error))completionBlock&lt;/h4&gt;

&lt;p&gt;Sets the provided JSON object (NSDictionary) to the given path, overwriting existing objects at specified paths but leaving unspecified children objects untouched.&lt;/p&gt;

&lt;h4 id=&#34;void-setofflinevalue-id-offlinevalue-forobjectatpath-nsstring-path-withpersistence-bool-persist-andcompletion-void-bool-success-nserror-error-completionblock&#34;&gt;+ (void)setOfflineValue:(id)offlineValue forObjectAtPath:(NSString *)path withPersistence:(BOOL)persist andCompletion:(void (^)(BOOL success, NSError *error))completionBlock&lt;/h4&gt;

&lt;p&gt;Firebase can automatically set an object to a path when the device&amp;rsquo;s connection to Firebase goes offline. However, in the stock API this actions is performed only once. This method allows you to persist an offline value that will be set to the provided path each and every time your device disconnects from Firebase.&lt;/p&gt;

&lt;h4 id=&#34;void-setonlinevalue-id-onlinevalue-forobjectatpath-nsstring-path-withpersistence-bool-persist&#34;&gt;+ (void)setOnlineValue:(id)onlineValue forObjectAtPath:(NSString *)path withPersistence:(BOOL)persist&lt;/h4&gt;

&lt;p&gt;Firebase can automatically set an object to a path when the device&amp;rsquo;s connection to Firebase is established. However, in the stock API this actions is performed only once. This method allows you to persist an online value that will be set to the provided path each and every time your device connects to Firebase.&lt;/p&gt;

&lt;h4 id=&#34;void-persistonlinevalueforobjectatpath-nsstring-path&#34;&gt;+ (void)persistOnlineValueForObjectAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;This method, when called while an active Firebase connection is present, allows you to persist and resume the current value at the specified path whenever the device is connected to Firebase. If this method is not called while an offline value is set for the path, the prior value will not be re-set upon connection to Firebase.&lt;/p&gt;

&lt;h4 id=&#34;void-clearofflinevalueforobjectatpath-nsstring-path&#34;&gt;+ (void)clearOfflineValueForObjectAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;If an offline value has been set for the given path, this method will clear it.&lt;/p&gt;

&lt;h4 id=&#34;void-clearonlinevalueforobjectatpath-nsstring-path&#34;&gt;+ (void)clearOnlineValueForObjectAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;If an online value has been set for the given path, this method will clear it.&lt;/p&gt;

&lt;h4 id=&#34;void-clearpersistedvalueforobjectatpath-nsstring-path&#34;&gt;+ (void)clearPersistedValueForObjectAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;If a persisted value has been set for the given path, this method will clear it.&lt;/p&gt;

&lt;h2 id=&#34;query-methods&#34;&gt;Query Methods&lt;/h2&gt;

&lt;h4 id=&#34;void-getobjectatpath-nsstring-path-withcompletion-void-id-object-completionblock&#34;&gt;+ (void)getObjectAtPath:(NSString *)path withCompletion:(void (^)(id object))completionBlock&lt;/h4&gt;

&lt;p&gt;Returns the object at the specified path via the completion handler.&lt;/p&gt;

&lt;h4 id=&#34;void-getobjectsatpath-nsstring-path-withqueries-nsarray-kmhfirebasequery-queries-andcompletion-void-id-result-completionblock&#34;&gt;+ (void)getObjectsAtPath:(NSString *)path withQueries:(NSArray &lt;KMHFirebaseQuery *&gt; *)queries andCompletion:(void (^)(id result))completionBlock&lt;/h4&gt;

&lt;p&gt;Returns all child objects of the specified path matching the provided query constraints via the completion handler. Note that in order for this method not to error the authenticated user must have read access to all descendants of the specified path including children-of-children.&lt;/p&gt;

&lt;h2 id=&#34;observer-methods&#34;&gt;Observer Methods&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;N.b. For all observer methods, an object or child object must exist at the specified path in order to add an observer. In contrast to the stock API, methods below will call the provided responder blocks exactly once per update and will not call blocks when observers are initially added. Also in contrast with the stock API, the methods below allow for only one responder block per path per observation type (i.s., value changed, child added, child changed, and child removed).&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;void-observevaluechangedatpath-nsstring-path-withblock-void-id-value-block&#34;&gt;+ (void)observeValueChangedAtPath:(NSString *)path withBlock:(void (^)(id value))block&lt;/h4&gt;

&lt;p&gt;Adds an observer at the specified path that will trigger the provided block when the object at the given path is changed.&lt;/p&gt;

&lt;h4 id=&#34;void-observechildaddedatpath-nsstring-path-withblock-void-id-child-block&#34;&gt;+ (void)observeChildAddedAtPath:(NSString *)path withBlock:(void (^)(id child))block&lt;/h4&gt;

&lt;p&gt;Adds an observer at the specified path that will trigger the provided block when any number of child objects are added at the given path.&lt;/p&gt;

&lt;h4 id=&#34;void-observechildchangedatpath-nsstring-path-withblock-void-id-child-block&#34;&gt;+ (void)observeChildChangedAtPath:(NSString *)path withBlock:(void (^)(id child))block&lt;/h4&gt;

&lt;p&gt;Adds an observer at the specified path that will trigger the provided block when any child object at the given path changes.&lt;/p&gt;

&lt;h4 id=&#34;void-observechildremovedfrompath-nsstring-path-withblock-void-id-child-block&#34;&gt;+ (void)observeChildRemovedFromPath:(NSString *)path withBlock:(void (^)(id child))block&lt;/h4&gt;

&lt;p&gt;Adds an observer at the specified path that will trigger the provided block when any child object of the given path is removed.&lt;/p&gt;

&lt;h4 id=&#34;void-removevaluechangedobserveratpath-nsstring-path&#34;&gt;+ (void)removeValueChangedObserverAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;Removes the &amp;ldquo;value changed&amp;rdquo; observer from the given path.&lt;/p&gt;

&lt;h4 id=&#34;void-removechildaddedobserveratpath-nsstring-path&#34;&gt;+ (void)removeChildAddedObserverAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;Removes the &amp;ldquo;child added&amp;rdquo; observer from the given path.&lt;/p&gt;

&lt;h4 id=&#34;void-removechildchangedobserveratpath-nsstring-path&#34;&gt;+ (void)removeChildChangedObserverAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;Removes the &amp;ldquo;child changed&amp;rdquo; observer from the given path.&lt;/p&gt;

&lt;h4 id=&#34;void-removechildremovedobserveratpath-nsstring-path&#34;&gt;+ (void)removeChildRemovedObserverAtPath:(NSString *)path&lt;/h4&gt;

&lt;p&gt;Removes the &amp;ldquo;child removed&amp;rdquo; observer from the given path.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Better Way To Animate Table View Updates</title>
      <link>http://kenmhaggerty.com/blog/post/animating-tableview-updates/</link>
      <pubDate>Mon, 04 Jul 2016 17:58:44 -0400</pubDate>
      
      <guid>http://kenmhaggerty.com/blog/post/animating-tableview-updates/</guid>
      <description>&lt;p&gt;Whenever I find myself re-using a helper method in many of my classes or projects, I like to add it to a shared class I created called &lt;a href=&#34;https://github.com/kenmhaggerty/KMHGenerics&#34;&gt;&lt;strong&gt;KMHGenerics&lt;/strong&gt;&lt;/a&gt;. This class contains generically useful methods so that my actual code can remain as &lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;&amp;ldquo;dry&amp;rdquo;&lt;/a&gt; as possible.&lt;/p&gt;

&lt;p&gt;Today I&amp;rsquo;m going to talk about a method I wrote to animate complex updates to UITableViews. The KMHGenerics class shared &lt;a href=&#34;https://github.com/kenmhaggerty/KMHGenerics&#34;&gt;here on GitHub&lt;/a&gt; includes many other methods too, but I&amp;rsquo;ll save those for another blog post.&lt;/p&gt;

&lt;p&gt;Those of you familiar with UITableView methods are probably comfortable inserting, reordering, and deleting rows from your table view, but what happens if you want to perform a mix of these actions within a single animation? For example, how would you animate inserting a row at the end of your table view while simultaneously deleting the first row of your table view and reordering the remaing cells?&lt;/p&gt;

&lt;p&gt;If you are efficient and looking for the simplest solution, the answer is to call &lt;code&gt;[self.tableview reloadData]&lt;/code&gt; and update the entire table view at once. While this works, the lack of animations can be, in certain situations, extremely confusing to the user&amp;mdash;much like the following GIF:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;figure&#34;&gt;
  &lt;img src=&#34;http://kenmhaggerty.com/blog/blog/images/animating-tableview-updates/change-blindness.gif&#34;&gt;
&lt;/div&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;strong&gt;Above&lt;/strong&gt; An example of &lt;a href=&#34;https://en.wikipedia.org/wiki/Change_blindness&#34;&gt;change blindness&lt;/a&gt;. Can you spot the difference between the two images? A blank frame added between the two images breaks the visual continuity, making it much harder to spot changes. Similarly, when updates to UITableView are not animated, it can be very difficult to spot what changed. &lt;a href=&#34;https://www.csc.ncsu.edu/faculty/healey/PP/&#34;&gt;[Source]&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Instead, I&amp;rsquo;ve written the following method on UITableView to perform updates in a single animation:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kenmhaggerty/9c0124d7684413fec140263a3c435aa9.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This method takes in the follow ten parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;array&lt;/strong&gt;: The current state of the data supplying the table view.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;toArray&lt;/strong&gt;: The desired final state of your table view&amp;rsquo;s data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;section&lt;/strong&gt;: Which section of your table view to animate.&lt;sup id=&#34;ref_1&#34;&gt;&lt;a href=&#34;#footnote_1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;insertionAnimation&lt;/strong&gt;: What animation style to use when inserting new cells in your table view.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deletionAnimation&lt;/strong&gt;: What animation style to use when deleting cells from your table view.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setter&lt;/strong&gt;: A block that sets the data for your table view.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;insertedCells&lt;/strong&gt;: An optional block to execute on the cells that will be inserted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reorderedCells&lt;/strong&gt;: An optional block to execute on the cells that will be reodered.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deletedCells&lt;/strong&gt;: An optional block to execute on the cells that will be deleted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;completion&lt;/strong&gt;: An optional block to execute upon completion of all animations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To help illustrate, I&amp;rsquo;ve embedded an interactive demo below showing. Try it out and let me know what you think!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;figure&#34;&gt;
  &lt;iframe class=&#34;figureContent&#34; src=&#34;https://appetize.io/embed/qkm9627b77pvrr7rqf831ty84r?device=iphone4s&amp;scale=100&amp;autoplay=true&amp;orientation=portrait&amp;screenOnly=true&#34; width=&#34;320px&#34; height=&#34;480px&#34; scrolling=&#34;no&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;strong&gt;Above&lt;/strong&gt; Tap &amp;ldquo;Shuffle&amp;rdquo; to generate random data for the table view. By toggling the switch at top-left, you can see the difference between animated and instantaneous table view updates for yourself. &lt;a href=&#34;https://appetize.io&#34;&gt;[Created using Appetize.io]&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p class=&#34;footnotes&#34;&gt;
  &lt;a name=&#34;footnote_1&#34; href=&#34;#ref_1&#34;&gt;1&lt;/a&gt; Currently this method only supports updating one table view section at a time. At some point I should implement a version that supports updating multiple table view sections simultaneously, e.g., for when table view cells are moved between sections.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>App Architecture (or, Making Sure The Chef Isn&#39;t Performing Heart Surgery)</title>
      <link>http://kenmhaggerty.com/blog/post/app-architecture/</link>
      <pubDate>Fri, 01 Jul 2016 11:10:04 -0400</pubDate>
      
      <guid>http://kenmhaggerty.com/blog/post/app-architecture/</guid>
      <description>&lt;p&gt;When I think about classes in Objective-C I imagine running a restaurant. A well run restaurant not only prepares good food but also provides excellent service and manages employees well. A good restaurant also delegates out whatever it cannot or should not do itself. For example: if a guest at your restaurant were in need of medical attention, you would probably call an ambulance and not ask your chef to attempt heart surgery (no matter how good he or she may be with knives).&lt;/p&gt;

&lt;p&gt;A well-built app follows similar principles. Your core functionalities should be grouped and split between classes so that each class has one area of expertise. Classes should communicate and depend on each other in a clear and coordinated fashion and not haphazardly. Classes should be independent of each other and self-contained. And certain things that are too complicated for you to do yourself or that are not core to the app (e.g., your backend) should be outsourced to third party libraries, frameworks, services, and APIs.&lt;/p&gt;

&lt;p&gt;When it came to building an app that both persists data locally and synchronizes data with a remote server (in this case, &lt;a href=&#34;https://www.firebase.com/&#34;&gt;Firebase&lt;/a&gt;), I spent some time making sure that what I built not only &lt;em&gt;worked&lt;/em&gt; but also &lt;em&gt;made sense&lt;/em&gt;. This involved a lot of trial and error, building and rebuilding, and, of course, refactoring. Ultimately, though, I&amp;rsquo;ve come around to the following architecture which, to me, seems pretty universal:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://docs.google.com/drawings/d/1YN09kkYLQymJxVmq-IKgZCWBX5KSdaOVN6uZKN-g5xk/pub?w=487&amp;amp;h=383&#34;&gt;
&lt;/div&gt;
&lt;span class=&#34;caption&#34;&gt;&lt;strong&gt;Above&lt;/strong&gt; Abstracting apart classes for managing local data storage (Core Data Controller), remote data storage (Firebase Controller), and synchronization (Sync Engine) allows for a cleaner interface with our app (Data API) and greater flexibility should we need to change backend providers.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;In the above diagram, all requests for data are routed through the &lt;strong&gt;Data Manager&lt;/strong&gt;. This includes everything from fetching data to deleting data to synchronizing data. Requests involving local data are then routed to our &lt;strong&gt;Core Data Controller&lt;/strong&gt;, while requests involving our remote database are routed to our &lt;strong&gt;Sync Engine&lt;/strong&gt;. Our Core Data Controller then interacts with our data objects directly (in this case, our &lt;strong&gt;Managed Objects&lt;/strong&gt;), while our Sync Engine directs remote database requests to Firebase via our intermediary &lt;strong&gt;Firebase Controller&lt;/strong&gt; class.&lt;/p&gt;

&lt;p&gt;The arrows in the diagram indicate the logical flow between classes. They also represent dependencies between classes. To avoid circular dependencies, there should be no double-headed arrows; the only exception here is between our Sync Engine and our backend (i.e., Firebase Controller).&lt;sup id=&#34;ref_1&#34;&gt;&lt;a href=&#34;#footnote_1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Some of the arrows between our classes have dotted lines. That&amp;rsquo;s just to show that the connection between these classes are weaker. The dotted line from our Data Manager to our Sync Engine simply indicates that these two classes are connected only so that our Data Manager can manually trigger a sync if necessary (e.g., when the user taps a reload button). Meanwhile, the dotted lines between our Managed Objects and our Sync Engine represent NSNotifications sent out by our Managed Objects when certain key values change; our Sync Engine listens for these notifications and, in response, pushes these changes to our remote server via our Firebase Controller.&lt;/p&gt;

&lt;p&gt;Our diagram above is also organized so that our most app-facing classes are at the top and our most back-end facing classes are towards the bottom.&lt;/p&gt;

&lt;p&gt;This diagram also includes a &lt;strong&gt;Notifications Controller&lt;/strong&gt; for scheduling and managing local notifications. When our app receives a local notification, our &lt;strong&gt;App Delegate&lt;/strong&gt; handles the response. While local notifications aren&amp;rsquo;t part of our synchonization scheme, you can see how its architecture resembles that of our Firebase Controller. This allows our app to be easily extended without extensive refactoring.&lt;/p&gt;

&lt;p&gt;If organizing the &amp;ldquo;model&amp;rdquo; component of our &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html&#34;&gt;MVC architecture&lt;/a&gt; in this way makes sense, then we can begin to investigate how actually to implement it in an app. In my next few blog posts, I&amp;rsquo;ll delve deeper into how I did this in my newest app &lt;a href=&#34;https://www.appstore.com/pushquery&#34;&gt;PushQuery&lt;/a&gt;, including &lt;a&gt;tips and tricks to working with Core Data&lt;/a&gt;; &lt;a&gt;using protocols to abstract implementation from interface&lt;/a&gt;; &lt;a&gt;realtime synchronization via Firebase&lt;/a&gt;; and &lt;a&gt;how to schedule and update local notifications&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Questions? Feedback? Let me know!&lt;br /&gt;
&lt;a href=&#34;mailto:kenmhaggerty@gmail.com?Subject=Re:%20[Blog]%20App%20Architecture&#34;&gt;kenmhaggerty@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p class=&#34;footnotes&#34;&gt;
&lt;a name=&#34;footnote_1&#34; href=&#34;#ref_1&#34;&gt;1&lt;/a&gt; Our Sync Engine is a delegate of our Firebase Controller that updates our local data store when our Firebase Controller receives updates from our remote server. This architecture is specific but not unique to the way Firebase works.
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>